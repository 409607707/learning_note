### 什么是构建工具

> 浏览器只认识html、css、js

#### 企业级项目里都可能会具备那些功能

1. typescript： 如果遇到TS文件，我们需要使用tsc代码转换为js代码
2. React/Vue：安装react-compiler / vue-compiler，将我们写的jsx文件或者.vue文件转换为render函数
3. less / sass/postcss/component-style:我们需要安装less-loader、sass-loader等一系列编译工具
4. 语法降级：babel  ---> 将ES的新语法转换为旧版浏览器可以接收的语法
5. 体积优化：uglifyjs  -->将我们的代码进行压缩变成体积更小性能更高的文件
6. ……

稍微改一点东西，非常麻烦，需要将App.tsx ---> App.jsx  —>  React-compiler   ———> App.js文件

有一个东西可以帮你把tsc，react-compiler，less，babel、uglifyjs全部集成到一起

我们只需要关心我们写的代码就好了

我们写的代码一变  ---> 有人帮我们自动调用tsc，react-compiler，less，babel、uglifyjs挨个走一遍  ---> js文件

这个东西就叫做**构建工具** 

> 打包：将我们写的浏览器不认识的代码交给构建工具进行编译处理的过程叫做打包，打包完成后会给我们一个浏览器可以认识的文件

#### 一个构建工具承担了哪些功能

1. 模块化开发支持：支持直接从node_modules中引入代码 + 多种模块化
2. 处理代码兼容性：比如babel语法降级，less、ts语法转换(**不是构建工具做的，构建工具将这些语法对应的处理工具集成进来自动化处理**)
3. 提高项目性能：压缩文件，代码分割
4. 优化开发体验：
   - 构建工具会自动监听文件的变化，当文件变化以后自动帮你调用对应的集成工具进行重新打包，然后再浏览器中运行(整个过程叫做热更新，HMR)
   - 开发服务器：跨域的问题，用



构建工具他让我们可以不用每次都关心我们的代码在浏览器中如何运行，我们只需要首次给构建工具提供一个配置文件(这个配置文件不是必须的，如果不提供，有默认的)，有了这个集成的配置文件以后，我们就可以在下次需要更新的时候调用一次对应的命令就好了，如果我们在结合热更新，我们就更加不需要管任何东西，这就是构建工具做的事，**它让我们不用关心生产的代码，也不用关心如何在浏览器运行，只需要关心我们的开发怎么写的爽就怎么写就好了**



#### 市面上主流的构建工具有哪些

- webpack
- vite
- parcel
- esbuild
- rollup
- grant
- gulp



### vite相较于webpack的优势

当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。我们开始遇到性能瓶颈 —— 使用 JavaScript 开发的工具通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用 HMR，文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。



起因：我们的项目越大  —> 构建工具(webpack)所要处理的js代码就越多[跟webpack的一个构建过程(工作流)有关系]

造成的结果：构建工具需要很长的时间才能启动开发服务器(启动开发服务器   --->  把项目跑起来)



webpack能不能改：如果一旦要改，那么将会动到webpack的大动脉

webpack支持多种模块化：它一开始必须要要统一模块化代码，所以意味着它需要将所有的依赖全部走一遍

vite会不会直接把webpack干掉：vite是基于es module实现的，侧重点不一样，webpack更多的关注兼容性，而vite关注浏览器端的开发体验



### vite脚手架和vite

```js
npm create vite
1. 帮我们全局安装一个东西：create-vite(vite脚手架)
2. 直接运行这个create-vite bin目录下的一个执行配置
```

很多人存在的误区：**认为官网中对应npm create构建项目的过程也是vite在做的事情**

create-vite和vite的关系是什么：create-vite内置了vite



### 依赖预构建

在处理的过程中如果遇到非绝对路径或者相对路径的引用，他则会尝试开启路径补全

找寻依赖的过程是自当前目录依次向上查找的过程，直到搜寻到根目录或者搜寻到对应依赖为止

1. 首先vite会找到对应的依赖，然后调用ESBuild(对js语法进行处理的一个库)，将其他规范的代码转换成es module规范
2. 然后放到当前目录下的node_modules/.vite/deps
3. 同时对esmodule规范的各个模块进行统一集成

他解决了三个问题：

1. 不同的第三方包会有不同的导出格式(这个是vite没法约束人家的事情)
2. 一次性对路径上的处理可以直接使用.vite/deps，方便路径重写
3. 叫做网络多包传输的性能问题(也是原生esmodule规范不敢支持node_modules的原因之一)，有了依赖预构建以后无论他有多少额外export和import，vite都会尽可能的将他们进行集成，最后只生成一个或者几个模块

